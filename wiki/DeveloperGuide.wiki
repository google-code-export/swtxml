#summary Tutorial and guide for developers

<wiki:toc/>

= Installation =

SWT/XML IDE requires Eclipse IDE for RCP/Plug-in Developers, at least version 3.4. It can be installed in different ways. If in doubt use the update site:

  * *Update site*: Help ⇒ Software Update ⇒ Available Software ⇒ Add Site ⇒ Update site: {{{http://www.swtxml.com/updates/}}} ⇒ select SWT/XML ⇒ Install

  * *Local update site*: [http://code.google.com/p/swtxml/downloads/list Download SWT/XML], Help ⇒ Software Update ⇒ Available Software ⇒ Add Site ⇒ Local ⇒ Choose {{{update-site}}} folder from the unzipped files

  * *Eclipse dropins folder*: [http://code.google.com/p/swtxml/downloads/list Download SWT/XML], copy the dropins folder from the unzipped files to your Eclipse installation

= Getting started =

  * For trying out SWT/XML create a Plug-in project and add a dependency to the "com.swtxml" plug-in

  * Create a new SWT/XML file using File ⇒ New ⇒ Other ⇒ SWT/XML ⇒ SWT/XML Class. You need to specify a class name and the base type. Every SWT/XML markup file is accompanied by a view class with the same name (which extends a SWT/XML base class):
    http://swtxml.googlecode.com/svn/trunk/img/class_swtxml.png

  * You can get a preview for swtxml files with Window ⇒ Show View ⇒ SWT/XML ⇒ SWT/XML ⇒ SWT/XML Preview. It is updated whenever you save an active SWT/XML editor. The editor has full content assist for SWT/XML markup syntax, so you should be able to use Ctrl+Space everywhere.

= SWT Markup syntax =

  * The meaning of the XML tags is defined by their *namespace*. The namespace to create SWT widgets is {{{http://www.swtxml.com/swt}}}. This namespace provides a *1:1 mapping from SWT widget classes to XML tags*. If you're familiar with SWT, you only need to learn few rules. The root tag of the document is always {{{Composite}}}:
    {{{
<?xml version="1.0" encoding="utf-8"?>
<Composite xmlns="http://www.swtxml.com/swt">
</Composite>
    }}}


  * Every *widget* class is represented by a XML tag. So you have {{{<Button/>}}}, {{{<Text/>}}}, {{{<Label/>}}} and so on:
    {{{
<?xml version="1.0" encoding="utf-8"?>
<Composite xmlns="http://www.swtxml.com/swt">
    <Button/>
</Composite>
    }}}
 

  * Composite tags can have *childs* - these are added to the containing composite: 
    {{{
<Composite>
    <Label/> 
    <Text/> 
</Composite> 
    }}}
 
  * Every *setter* method of the widget class is an attribute for the tag. For example: button.setText("sometext") is {{{<Button text="sometext"/>}}}:
    {{{
<Button text="hello" enabled="false"/>
    }}}

  * *Style* constants are specified with the style attribute as a comma separated list:
    {{{
<Button text="hello" style="TOGGLE,FLAT"/>
    }}}

  * *Colors* are specified by name (as defined in {{{SWT.COLOR_*}}}) or by a [http://en.wikipedia.org/wiki/Web_colors#Hex_triplet hex triplet]:
    {{{
<Label foreground="red" background="#EE0000"/>
    }}}

  * *Images* can be specified using a path relative to the .swtxml file. You can refer to the root of the containing plugin using the scheme prefix "{{{bundle:}}}":
    {{{
<Label image="someimage.png"/>
<Label image="bundle:/icons/someicon.png"/>
    }}}

= Implementing the view class =

  * The superclass of your view parses the markup and creates the widgets.

  * Override the {{{setupView}}} method with your custom code to be executed after the widgets were created from the XML markup.

  * To access the widget objects in your code add an {{{id="someControl"}}} attribute in your markup and declare a field {{{"someControl"}}} annotated with {{{@ById}}}. The value for this field will be injected by the SWT/XML parser before {{{setupView}}} is called.
    {{{
<?xml version="1.0" encoding="utf-8"?>
<Composite xmlns="http://www.swtxml.com/swt">
    <Button text="helloWorld" id="btnHelloWorld"/>
</Composite>
}}}
    {{{
import org.eclipse.swt.widgets.*;
import com.swtxml.container.SwtXmlShell;
import com.swtxml.swt.byid.ById;

public class SwtWidgetsExamplesWindow extends SwtXmlShell {

	@ById
	private Button btnHelloWorld;

	@Override
	protected void setupView() {
		//do something with the widgets here
	}

}
}}}

= Layouts =

  * Composite elements can have a layout attribute which is interpreted in CSS-like syntax. All setters and public fields of the Layout class can be specified here:

    {{{
<Composite layout="layout:grid; numColumns:3; marginTop:10; "/>
}}}

  * Child tags of Composite tags can specify a {{{layoutData}}} attribute. You can use all properties of the related {{{LayoutData}}} class here:
    {{{
<Composite layout="layout:grid; numColumns:2; "> 
    <Label text="123" layoutData="widthHint:100;"/> 
    <Text text="456"/> 
</Composite> 
}}}

  * {{{FormLayout}}} works the same way and comes with a compact syntax for expressing the layout constraints:
    {{{
<Composite layout="layout:form;spacing:3;">
    <Label id="test" text="Test:" layoutData="top:10;left:10;"/>
    <Text style="BORDER" layoutData="top:test.top; left:test+20; right:100%-10;"/>
</Composite>
}}}

= Events =

   * The namespace {{{http://www.swtxml.com/events}}} provides an attribute for every event listener method (like {{{widgetSelected}}} from {{{SelectionListener}}}). When the event is triggered, a method by that name is called on your view class (optionally the event parameter can be declared and is passed to the method):
    {{{
<?xml version="1.0" encoding="utf-8"?>
<Composite xmlns="http://www.swtxml.com/swt" xmlns:on="http://www.swtxml.com/events">
    <Button text="helloWorld" on:widgetSelected="onHelloClicked"/>
</Composite>
}}}
    {{{
public class SwtWidgetsExamplesWindow extends SwtXmlShell {

	private void onHelloClicked() {
		//handle event here
	}

}
}}}

= I18N =

   * To translate your views, you can use placeholders in all text attributes:
    {{{
<Button text="%hello"/>
}}}

   * These are resolved using resource bundles (same name and location as the markup file or plugin.properties for Eclipse RCP applications).